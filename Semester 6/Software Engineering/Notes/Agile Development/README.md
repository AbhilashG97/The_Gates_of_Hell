# Agile Development

## Introduction

Agile software engineering combines a philosophy and a set of development guidelines.

:warning:  One of the most compelling characteristics of the agile approach is its ability to reduce the costs of change throughout the software process.

:exclamation: An agile team is a nimble team able to appropriately respond to changes.

An agile team recognizes that software is developed by individuals working in teams and that the skills of these people, their ability to collaborate is at the core for the success of the project.

It also adopts the customer as a part of the development team and works to eliminate the “us and them” attitude that continues to pervade many software projects.

## Agility and the cost of change

The conventional wisdom in software development (supported by decades of experience) is that the **cost of change increases nonlinearly as a project progresses**.

It is relatively easy to accommodate a change when a software team is gathering requirements (early in a project).

The costs of making a change in the initial stages of the project is quite less and it also takes very less time to make those changes.

However, if the change is to be made at a later stage in the process, costs escalate quickly, and the time and cost required to ensure that the change is made without unintended side effects is nontrivial.

Proponents of agility argue that a well-designed agile process **flattens** the cost of change curve, allowing a software team to accommodate changes late in a software project without dramatic cost and time impact.

## What is an Agile Process?

An agile process must be **adaptable**.

But continual adaptation without forward progress accomplishes little. Therefore, an agile software process must **adapt incrementally**. 

To accomplish incremental adaptation, an agile team requires customer feedback. An effective catalyst for customer feedback is an operational prototype or a portion of an operational system.

:exclamation: **Software increments** (executable prototypes or portions of an operational system) must be delivered in **short time periods** so that adaptation keeps pace with change (unpredictability). This iterative approach enables the customer to evaluate the software increment regularly.

### Agility Principles

The Agile Alliance defines 12 agility principles for those who want to achieve agility: 

1. Our highest priority is to satisfy the customer through early and continuous delivery of valuable software.

1. Welcome changing requirements, even late in development. Agile processes harness change for the customer’s competitive advantage.

1. Deliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale

1. Business people and developers must work together daily throughout the project.

1. Build projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.

1. The most efficient and effective method of conveying information to and within a development team is face-to-face conversation.

1. Working software is the primary measure of progress.

1. Agile processes promote sustainable development. The sponsors, developers,and users should be able to maintain a constant pace indefinitely.

1. Continuous attention to technical excellence and good design enhances agility.

1. Simplicity —the art of maximizing the amount of work not done— is essential.

1. The best architectures, requirements, and designs emerge from self–organizing teams.

1. At regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.

Not every agile process model applies all the 12 principals with equal weight, they may choose to even ignore some of the pricipals.

### Human Factors

Agile development focuses on the talents and skills of individuals, molding the process to specific people and teams. 

The following number of key traits must exist among the people on an agile team - 

1. **Competance** 

Skill and knowledge of process can and should be taught to all people who serve as agile team members.

1. **Common focus**

Although members of the agile team may perform different tasks and bring different skills to the project, all should be focused on one goal, i.e to deliver a working software increment to the customer within the
time promised.

1. **Collaboration**

Software engineering (regardless of process) is about assessing, analyzing, and using information that is communicated to the software team. In order to achive the maximum all the members of the team including the customer have to collaborate with each other.

1. **Decision-making ability**

Any good software team (including agile teams) must be given the freedom to control its own destiny. This implies that the team is given autonomy — decision-making authority for both technical and project issues.

1. **Fuzzy problem-solving ability**

Software managers must recognize that the agile team will continually have to deal with ambiguity and will continually be buffeted by change. The problem that the team is solving now may not bne the solution tomorrow. The team needs to accept that and whatever lessson they learn after solving the problem might be useful to the team afterwards.

1. **Mutual trust and respect**

An Agile team must be like a **jelled team**. A jelled team exhibits the trust and respect that are necessary to make them “so strongly knit that the whole is greater than the sum of the parts.”

1. **Self-organization**

    In the context of agile development, self-organization implies three things:
    
    1. The agile team organizes itself for the work to be done.
    1. The team organizes the process to best accommodate its local environment.
    1. The team organizes the work schedule to best achieve delivery of the software increment.

## Extreme Programming

**Extreme Programming** uses an object-oriented approach as its preferred development paradigm and encompasses a set of rules and practices that occur within the context of four framework activities: 

1. planning 
1. design
1. coding
1. testing.